From: Zebediah Figura <z.figura12@gmail.com>
Subject: [PATCH v4 1/3] ntdll: Reimplement NtQuerySystemInformation(SystemProcessInformation) using a single server call.
Message-Id: <20200705214723.1762237-1-zfigura@codeweavers.com>
Date: Sun,  5 Jul 2020 16:47:21 -0500

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
---
v4: always align to 8 bytes, which will be necessary if 8-byte types are added
to the process_info and thread_info structures. We cannot rely on TYPE_ALIGNMENT
in this case as "long long" has alignment 4 on i386.

 dlls/ntdll/nt.c | 177 ++++++++++++++++-----------------------
 server/process.c         |  64 ++++++++++++++
 server/protocol.def      |  30 +++++++
 server/trace.c           |  35 ++++++++
 4 files changed, 202 insertions(+), 104 deletions(-)

diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
index 7045bc1550b..91df9bdb5f5 100644
--- a/dlls/ntdll/nt.c
+++ b/dlls/ntdll/nt.c
@@ -2762,142 +2762,105 @@ NTSTATUS WINAPI NtQuerySystemInformation(
         }
         break;
     case SystemProcessInformation:
+    {
+        unsigned int process_count, i, j;
+        char *buffer = NULL;
+        unsigned int pos = 0;
+        unsigned long clk_tck = sysconf(_SC_CLK_TCK);
+
+        if (Length && !(buffer = RtlAllocateHeap( GetProcessHeap(), 0, Length )))
+        {
+            ret = STATUS_NO_MEMORY;
+            break;
+        }
+
+        SERVER_START_REQ( list_processes )
+        {
+            wine_server_set_reply( req, buffer, Length );
+            ret = wine_server_call( req );
+            len = reply->info_size;
+            process_count = reply->process_count;
+        }
+        SERVER_END_REQ;
+
+        if (ret)
         {
-            SYSTEM_PROCESS_INFORMATION* spi = SystemInformation;
-            SYSTEM_PROCESS_INFORMATION* last = NULL;
-            unsigned long clk_tck = sysconf(_SC_CLK_TCK);
-            HANDLE hSnap = 0;
-            WCHAR procname[1024];
-            WCHAR* exename;
-            DWORD wlen = 0;
-            DWORD procstructlen = 0;
-            int unix_pid = -1;
-
-            SERVER_START_REQ( create_snapshot )
+            RtlFreeHeap( GetProcessHeap(), 0, buffer );
+            break;
+        }
+
+        len = 0;
+
+        for (i = 0; i < process_count; i++)
+        {
+            SYSTEM_PROCESS_INFORMATION *nt_process = (SYSTEM_PROCESS_INFORMATION *)((char *)SystemInformation + len);
+            const struct process_info *server_process;
+            const WCHAR *server_name, *file_part;
+            ULONG proc_len;
+            ULONG name_len = 0;
+
+            pos = (pos + 7) & ~7;
+            server_process = (const struct process_info *)(buffer + pos);
+            pos += sizeof(*server_process);
+
+            server_name = (const WCHAR *)(buffer + pos);
+            file_part = server_name + (server_process->name_len / sizeof(WCHAR));
+            pos += server_process->name_len;
+            while (file_part > server_name && file_part[-1] != '\\')
             {
-                req->flags      = SNAP_PROCESS | SNAP_THREAD;
-                req->attributes = 0;
-                if (!(ret = wine_server_call( req )))
-                    hSnap = wine_server_ptr_handle( reply->handle );
+                file_part--;
+                name_len++;
             }
-            SERVER_END_REQ;
-            len = 0;
-            while (ret == STATUS_SUCCESS)
-            {
-                SERVER_START_REQ( next_process )
-                {
-                    req->handle = wine_server_obj_handle( hSnap );
-                    req->reset = (len == 0);
-                    wine_server_set_reply( req, procname, sizeof(procname)-sizeof(WCHAR) );
-                    if (!(ret = wine_server_call( req )))
-                    {
-                        /* Make sure procname is 0 terminated */
-                        procname[wine_server_reply_size(reply) / sizeof(WCHAR)] = 0;
-
-                        /* Get only the executable name, not the path */
-                        if ((exename = wcsrchr(procname, '\\')) != NULL) exename++;
-                        else exename = procname;
-
-                        wlen = (wcslen(exename) + 1) * sizeof(WCHAR);
-
-                        procstructlen = sizeof(*spi) + wlen + ((reply->threads - 1) * sizeof(SYSTEM_THREAD_INFORMATION));
-
-                        if (Length >= len + procstructlen)
-                        {
-                            /* ftCreationTime;
-                             * vmCounters, ioCounters
-                             */
- 
-                            memset(spi, 0, sizeof(*spi));
-
-                            spi->NextEntryOffset = procstructlen - wlen;
-                            spi->dwThreadCount = reply->threads;
-
-                            /* spi->pszProcessName will be set later on */
-
-                            spi->dwBasePriority = reply->priority;
-                            spi->UniqueProcessId = UlongToHandle(reply->pid);
-                            spi->ParentProcessId = UlongToHandle(reply->ppid);
-                            spi->HandleCount = reply->handles;
-                            spi->CreationTime.QuadPart = reply->start_time;
-
-                            /* spi->ti will be set later on */
-
-                            if (reply->unix_pid != -1)
-                            {
-                                read_process_time(reply->unix_pid, -1, clk_tck,
-                                                  &spi->KernelTime, &spi->UserTime);
-                                read_process_memory_stats(reply->unix_pid, &spi->vmCounters);
-                            }
-                            unix_pid = reply->unix_pid;
-                        }
-                        len += procstructlen;
-                    }
-                }
-                SERVER_END_REQ;
- 
-                if (ret != STATUS_SUCCESS)
-                {
-                    if (ret == STATUS_NO_MORE_FILES) ret = STATUS_SUCCESS;
-                    break;
-                }
 
-                if (Length >= len)
-                {
-                    int     i, j;
+            proc_len = sizeof(*nt_process) + server_process->thread_count * sizeof(SYSTEM_THREAD_INFORMATION)
+                         + (name_len + 1) * sizeof(WCHAR);
+            len += proc_len;
 
-                    /* set thread info */
-                    i = j = 0;
-                    while (ret == STATUS_SUCCESS)
-                    {
-                        SERVER_START_REQ( next_thread )
-                        {
-                            req->handle = wine_server_obj_handle( hSnap );
-                            req->reset = (j == 0);
-                            if (!(ret = wine_server_call( req )))
-                            {
-                                j++;
-                                if (UlongToHandle(reply->pid) == spi->UniqueProcessId)
-                                {
-                                    /* ftKernelTime, ftUserTime, ftCreateTime;
-                                     * dwTickCount, dwStartAddress
-                                     */
-
-                                    memset(&spi->ti[i], 0, sizeof(spi->ti));
-
-                                    spi->ti[i].CreateTime.QuadPart = reply->creation_time;
-                                    spi->ti[i].ClientId.UniqueProcess = UlongToHandle(reply->pid);
-                                    spi->ti[i].ClientId.UniqueThread  = UlongToHandle(reply->tid);
-                                    spi->ti[i].dwCurrentPriority = reply->base_pri + reply->delta_pri;
-                                    spi->ti[i].dwBasePriority = reply->base_pri;
-
-                                    if (unix_pid != -1 && reply->unix_tid != -1)
-                                        read_process_time(unix_pid, reply->unix_tid, clk_tck,
-                                                          &spi->ti[i].KernelTime, &spi->ti[i].UserTime);
-                                    i++;
-                                }
-                            }
-                        }
-                        SERVER_END_REQ;
-                    }
-                    if (ret == STATUS_NO_MORE_FILES) ret = STATUS_SUCCESS;
+            if (len <= Length)
+            {
+                memset(nt_process, 0, sizeof(*nt_process));
+                if (i < process_count - 1)
+                    nt_process->NextEntryOffset = proc_len;
+                nt_process->dwThreadCount = server_process->thread_count;
+                nt_process->dwBasePriority = server_process->priority;
+                nt_process->UniqueProcessId = UlongToHandle(server_process->pid);
+                nt_process->ParentProcessId = UlongToHandle(server_process->parent_pid);
+                nt_process->HandleCount = server_process->handle_count;
+                read_process_time( server_process->unix_pid, -1, clk_tck, &nt_process->KernelTime, &nt_process->UserTime );
+            }
 
-                    /* now append process name */
-                    spi->ProcessName.Buffer = (WCHAR*)((char*)spi + spi->NextEntryOffset);
-                    spi->ProcessName.Length = wlen - sizeof(WCHAR);
-                    spi->ProcessName.MaximumLength = wlen;
-                    memcpy( spi->ProcessName.Buffer, exename, wlen );
-                    spi->NextEntryOffset += wlen;
+            pos = (pos + 7) & ~7;
+            for (j = 0; j < server_process->thread_count; j++)
+            {
+                const struct thread_info *server_thread = (const struct thread_info *)(buffer + pos);
 
-                    last = spi;
-                    spi = (SYSTEM_PROCESS_INFORMATION*)((char*)spi + spi->NextEntryOffset);
+                if (len <= Length)
+                {
+                    nt_process->ti[j].CreateTime.QuadPart = 0xdeadbeef;
+                    nt_process->ti[j].ClientId.UniqueProcess = UlongToHandle(server_process->pid);
+                    nt_process->ti[j].ClientId.UniqueThread = UlongToHandle(server_thread->tid);
+                    nt_process->ti[j].dwCurrentPriority = server_thread->current_priority;
+                    nt_process->ti[j].dwBasePriority = server_thread->base_priority;
+                    read_process_time( server_process->unix_pid, server_thread->unix_tid,
+                                       clk_tck, &nt_process->ti[j].KernelTime, &nt_process->ti[j].UserTime );
                 }
+
+                pos += sizeof(*server_thread);
+            }
+
+            if (len <= Length)
+            {
+                nt_process->ProcessName.Buffer = (WCHAR *)&nt_process->ti[server_process->thread_count];
+                nt_process->ProcessName.Length = name_len * sizeof(WCHAR);
+                nt_process->ProcessName.MaximumLength = (name_len + 1) * sizeof(WCHAR);
+                memcpy(nt_process->ProcessName.Buffer, file_part, name_len * sizeof(WCHAR));
+                nt_process->ProcessName.Buffer[name_len] = 0;
             }
-            if (ret == STATUS_SUCCESS && last) last->NextEntryOffset = 0;
-            if (len > Length) ret = STATUS_INFO_LENGTH_MISMATCH;
-            if (hSnap) NtClose(hSnap);
         }
+
+        if (len > Length) ret = STATUS_INFO_LENGTH_MISMATCH;
         break;
+    }
     case SystemProcessorPerformanceInformation:
         {
             SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *sppi = NULL;
diff --git a/server/process.c b/server/process.c
index 283edc09c5e..00a8239d10f 100644
--- a/server/process.c
+++ b/server/process.c
@@ -22,6 +22,7 @@
 #include "wine/port.h"
 
 #include <assert.h>
+#include <errno.h>
 #include <limits.h>
 #include <signal.h>
 #include <string.h>
@@ -1819,3 +1820,66 @@ DECL_HANDLER(resume_process)
         release_object( process );
     }
 }
+
+/* Get a list of processes and threads currently running */
+DECL_HANDLER(list_processes)
+{
+    struct process *process;
+    struct thread *thread;
+    unsigned int pos = 0;
+    char *buffer;
+
+    reply->process_count = 0;
+    reply->info_size = 0;
+
+    LIST_FOR_EACH_ENTRY( process, &process_list, struct process, entry )
+    {
+        struct process_dll *exe = get_process_exe_module( process );
+        reply->info_size = (reply->info_size + 7) & ~7;
+        reply->info_size += sizeof(struct process_info) + exe->namelen;
+        reply->info_size = (reply->info_size + 7) & ~7;
+        reply->info_size += process->running_threads * sizeof(struct thread_info);
+        reply->process_count++;
+    }
+
+    if (reply->info_size > get_reply_max_size())
+    {
+        set_error( STATUS_INFO_LENGTH_MISMATCH );
+        return;
+    }
+
+    if (!(buffer = set_reply_data_size( reply->info_size ))) return;
+
+    memset( buffer, 0, reply->info_size );
+    LIST_FOR_EACH_ENTRY( process, &process_list, struct process, entry )
+    {
+        struct process_info *process_info;
+        struct process_dll *exe = get_process_exe_module( process );
+
+        pos = (pos + 7) & ~7;
+        process_info = (struct process_info *)(buffer + pos);
+        process_info->name_len = exe->namelen;
+        process_info->thread_count = process->running_threads;
+        process_info->priority = process->priority;
+        process_info->pid = process->id;
+        process_info->parent_pid = process->parent_id;
+        process_info->handle_count = get_handle_table_count(process);
+        process_info->unix_pid = process->unix_pid;
+        pos += sizeof(*process_info);
+
+        memcpy( buffer + pos, exe->filename, exe->namelen );
+        pos += exe->namelen;
+
+        pos = (pos + 7) & ~7;
+        LIST_FOR_EACH_ENTRY( thread, &process->thread_list, struct thread, proc_entry )
+        {
+            struct thread_info *thread_info = (struct thread_info *)(buffer + pos);
+
+            thread_info->tid = thread->id;
+            thread_info->base_priority = thread->priority;
+            thread_info->current_priority = thread->priority; /* FIXME */
+            thread_info->unix_tid = thread->unix_tid;
+            pos += sizeof(*thread_info);
+        }
+    }
+}
diff --git a/server/protocol.def b/server/protocol.def
index 6416306c0a1..2737cd6fddd 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1919,6 +1919,36 @@ enum char_info_mode
 @END
 
 
+struct thread_info
+{
+    thread_id_t     tid;
+    int             base_priority;
+    int             current_priority;
+    int             unix_tid;
+};
+
+struct process_info
+{
+    data_size_t     name_len;
+    unsigned int    thread_count;
+    int             priority;
+    process_id_t    pid;
+    process_id_t    parent_pid;
+    unsigned int    handle_count;
+    int             unix_pid;
+    /* VARARG(name,unicode_str,name_len); */
+    /* VARARG(threads,struct thread_info,thread_count); */
+};
+
+/* Get a list of processes and threads currently running */
+@REQ(list_processes)
+@REPLY
+    data_size_t     info_size;
+    unsigned int    process_count;
+    VARARG(data,process_info,info_size);
+@END
+
+
 /* Wait for a debug event */
 @REQ(wait_debug_event)
     int           get_handle;  /* should we alloc a handle for waiting? */
diff --git a/server/trace.c b/server/trace.c
index 2fb5afd5ef1..1680a1cff8f 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -1115,6 +1115,41 @@ static void dump_varargs_token_groups( const char *prefix, data_size_t size )
     fputc( '}', stderr );
 }
 
+static void dump_varargs_process_info( const char *prefix, data_size_t size )
+{
+    data_size_t pos = 0;
+    unsigned int i;
+
+    fprintf( stderr,"%s{", prefix );
+
+    while (size - pos >= sizeof(struct process_info))
+    {
+        const struct process_info *process;
+        pos = (pos + 7) & ~7;
+        process = (const struct process_info *)((const char *)cur_data + pos);
+        fprintf( stderr, "[thread_count=%u,priority=%d,pid=%04x,parent_pid=%04x,handle_count=%08x,unix_pid=%d,",
+                 process->thread_count, process->priority, process->pid,
+                 process->parent_pid, process->handle_count, process->unix_pid );
+        pos += sizeof(*process);
+
+        pos = dump_inline_unicode_string( "name=L\"", pos, process->name_len, size );
+
+        pos = (pos + 7) & ~7;
+        fprintf( stderr, "\",threads={" );
+        for (i = 0; i < process->thread_count; i++)
+        {
+            const struct thread_info *thread = (const struct thread_info *)((const char *)cur_data + pos);
+            if (size - pos < sizeof(*thread)) break;
+            fprintf( stderr, "[tid=%04x,base_priority=%d,current_priority=%d,unix_tid=%d],",
+                     thread->tid, thread->base_priority, thread->current_priority, thread->unix_tid );
+            pos += sizeof(*thread);
+        }
+        fprintf( stderr, "}," );
+    }
+
+    fputc( '}', stderr );
+}
+
 static void dump_varargs_object_attributes( const char *prefix, data_size_t size )
 {
     const struct object_attributes *objattr = cur_data;

-- 
2.27.0

