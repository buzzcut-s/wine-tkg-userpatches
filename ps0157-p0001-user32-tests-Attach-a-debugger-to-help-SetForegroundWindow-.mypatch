From: "Rémi Bernon" <rbernon@codeweavers.com>
Subject: [PATCH v2 1/5] user32/tests: Attach a debugger to help SetForegroundWindow succeed.
Message-Id: <20200902170102.324526-1-rbernon@codeweavers.com>
Date: Wed,  2 Sep 2020 19:00:58 +0200

This is not strictly required and it does not even work all the time
regardless of what MSDN says, but it helps, especially when multiple
processes are creating windows.

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
---

Note that this patch is completely optional and can be ignored. I had
more consistent results with it when running the test on my Windows 10
VM though but it doesn't seem to change much for the testbot.

v2: For the whole series, mostly whitespace fixes, and a rework of the
    fix implementation to avoid messing with the message queues.

 dlls/user32/tests/win.c | 50 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 50 insertions(+)

diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index 843da8900f1..c001247b651 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -11896,6 +11896,53 @@ static void test_other_process_window(const char *argv0)
     DestroyWindow(hwnd);
 }
 
+static void start_debugger( int argc, char **argv )
+{
+    HANDLE debug_ready;
+    BOOL ret;
+    char event_name[MAX_PATH];
+
+    if (argc == 4 && !strcmp( argv[2], "debugger" ))
+    {
+        DWORD pid;
+        DEBUG_EVENT de;
+
+        sprintf( event_name, "test_debug_%s", argv[3] );
+        debug_ready = OpenEventA( EVENT_ALL_ACCESS, FALSE, event_name );
+        ok( debug_ready != 0, "OpenEventA failed\n" );
+
+        sscanf( argv[3], "%x", &pid );
+        ret = DebugActiveProcess( pid );
+        ok( ret, "DebugActiveProcess failed, last error: %#x.\n", GetLastError() );
+
+        SetEvent( debug_ready );
+        ok( ret, "SetEvent failed, last error %#x.\n", GetLastError() );
+        CloseHandle( debug_ready );
+
+        while (WaitForDebugEvent( &de, INFINITE ))
+            ContinueDebugEvent( de.dwProcessId, de.dwThreadId, DBG_EXCEPTION_NOT_HANDLED );
+
+        exit( 0 );
+    }
+    else
+    {
+        PROCESS_INFORMATION pi;
+        STARTUPINFOA si = {sizeof(si)};
+        char cmd[MAX_PATH];
+
+        sprintf( event_name, "test_debug_%x", GetCurrentProcessId() );
+        debug_ready = CreateEventA( NULL, FALSE, FALSE, event_name );
+        ok( debug_ready != 0, "CreateEventA failed\n" );
+
+        sprintf( cmd, "%s win debugger %x", argv[0], GetCurrentProcessId() );
+        ret = CreateProcessA( NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi );
+        ok( ret, "CreateProcessA failed, last error: %#x.\n", GetLastError() );
+
+        WaitForSingleObject( debug_ready, INFINITE );
+        CloseHandle( debug_ready );
+    }
+}
+
 START_TEST(win)
 {
     char **argv;
@@ -11920,6 +11967,9 @@ START_TEST(win)
     pAdjustWindowRectExForDpi = (void *)GetProcAddress( user32, "AdjustWindowRectExForDpi" );
     pSystemParametersInfoForDpi = (void *)GetProcAddress( user32, "SystemParametersInfoForDpi" );
 
+    /* attaching a debugger to the current process will make sure SetForegroundWindow always succeed */
+    start_debugger( argc, argv );
+
     if (argc == 4)
     {
         HWND hwnd;

-- 
2.28.0

